---
title: "Analysis of GOT Series"
author: "kinmar01"
editor: visual
format: 
  html:           
    toc: true 
    toc-depth: 2
    embed-resources: true
  pdf:           
    toc: true 
    toc-depth: 2
format-links: false
number-sections: true
bibliography: bibliography.bib
output-file: index
---

exercise 4, part of the course cma (mainly based on @Laube2014)

# Abstract {.unnumbered .unlisted}

# [Input: Segmentation](https://computationalmovementanalysis.github.io/FS25/Week4/1_input.html)

You’ve read Laube and Purves ([2011](https://computationalmovementanalysis.github.io/FS25/90_references.html#ref-laube2011)) about segmenting trajectories. In the paper, the authors define “*static*” fixes as “*those whose average Euclidean distance to other fixes inside a temporal window v is less than some threshold d*”, as illustrated in @fig-laube-purves-2011

![The figure from Laube and Purves (2011) visualizes steps a) zu d), which will be explained below](fig-laube-purves-2011.png){#fig-laube-purves-2011}

a.  Specify a temporal windows v for in which to measure Euclidean distances.

b.  Measure the distance from every point to every other point within this temporal window v.

c.  Remove “static points”: These are points where the average distance is less than a given threshold. This segments the trajectory into subtrajectories.

d.  Now remove short subtrajectories: These are trajectories with a short duration (whereas “short” is tbd).

We will **demonstrate** implementing this method on the wild boar “Sabi”, restricting ourselves to a couple of tracking days. Your task will be to understand this implementation and apply it to your own movement data.

Open a RStudio Project for this week. Next, copy the wild boar data you downloaded last week (*wildschwein_BE_2056.csv*) to your project folder. If you cannot find this dataset on your computer, you can re-download it from moodle. Transform the data into an `sf` object, filter for the wild boar Sabi and a datetime between “2015-07-01” and “2015-07-03”.

```{r}
pacman::p_load("readr", "sf","dplyr", "ggplot2")

wildschwein <- read_delim("data/wildschwein_BE_2056.csv", ",")


# Careful! What Timezone is assumed?
sabi <- wildschwein |>
    st_as_sf(coords = c("E", "N"), crs = 2056, remove = FALSE) |>
    filter(
      TierName == "Sabi", 
      DatetimeUTC >= "2015-07-01", 
      DatetimeUTC < "2015-07-03"
      )

sabi |> summary()
sabi |> str()

```

```{r}
#| label: fig-sabi-1
#| fig-cap: "Movement of the wild boar ‘Sabi’ in the timespan 01 - 02.07.2015. The cluster of dots / fixes are possible ‘static’ points"

sabi |> 
  ggplot(aes(E,N)) +
  geom_point() +
  geom_path() +
  theme_minimal()
```

**Step a): Specify a temporal window** v

In the above dataset, the sampling interval is 15 minutes. If we take a temporal window of 60 minutes, that would mean including 4 fixes. We need to calculate the following Euclidean distances (pos representing single location):

1.  `pos[n-2]` to `pos[n]`
2.  `pos[n-1]` to `pos[n]`
3.  `pos[n]` to `pos[n+1]`
4.  `pos[n]` to `pos[n+2]`

**Step b): Measure the distance to every point within** v

We can use the function distance_by_element from week 2 in combination with `lead()` and `lag()` to calculate the Euclidean distance. For example, to create the necessary offset of n-2, we use `lag(x, 2)`. For each offset, we create one individual column.

```{r}
distance_by_element <- function(later, now) {
  as.numeric(
    st_distance(later, now, by_element = TRUE)
  )
}


sabi <- sabi |> 
  mutate(
    nMinus2 = distance_by_element(lag(geometry,2),geometry),
    nMinus1 = distance_by_element(lag(geometry,1),geometry),
    nPlus1 = distance_by_element(geometry,lead(geometry,1)),
    nPlus2 = distance_by_element(geometry,lead(geometry,2))
  )
```

Now we want to calculate the mean distance of `nMinus2`, `nMinus1`, `nPlus1`, `nPlus2` for each row. Since we want the mean value *per Row*, we have to explicitly specify this before `mutate()` with the function `rowwise()`. To remove this rowwise-grouping, we end the operation with `ungroup()`.

Note that for the first two positions, we cannot calculate a `stepMean` since there is no Position `n-2` for these positions. This is also true for the last to positions (lacking a position `n+2`).

```{r}
sabi <- sabi |>
    rowwise() |>
    mutate(
        stepMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))
    ) |>
    ungroup()
```

**Step c): Remove “static points”**

We can now determine if an animal is moving or not by specifying a threshold distance on `stepMean`. In our example, we use the mean value as a threshold: Positions with distances below this value are considered static.

```{r}
sabi <- sabi |>
    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

sabi_moving <- sabi |>
    filter(!static)
  
sabi_static <- sabi |>
    filter(static)
```


```{r}
#| label: fig-sabi-2
#| fig-cap: "The trajectory of sabi. Red dots are static points, the black dots signify moving points"
#| 
sabi_moving |>
    ggplot(aes(E, N)) +
    geom_point(data = sabi_static, col = "red") +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "bottom")
```

# References

::: {#refs}
:::
